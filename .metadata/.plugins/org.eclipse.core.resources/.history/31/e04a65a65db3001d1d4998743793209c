#include "robot.h"

extern struct Robot g_robot;

static struct MotorPin s_pin_1_motor_right, s_pin_2_motor_right;
static struct Motor s_motor_right;

static struct MotorPin s_pin_1_motor_left, s_pin_2_motor_left;
static struct Motor s_motor_left;

/*
 * Creates a new robot and initializes all global and static variables
 */
void createRobot() {
  // Motor right is set to the output of the left driver (due to the placement of the driver)
  initMotorPin(&s_pin_1_motor_right, GPIOB, 9);
  initMotorPin(&s_pin_2_motor_right, GPIOA, 12);
  initMotor(&s_motor_right, &s_pin_1_motor_right, &s_pin_2_motor_right);

  // Motor left is set to the output of the right driver (due to the placement of the driver)
  initMotorPin(&s_pin_1_motor_left, GPIOB, 8);
  initMotorPin(&s_pin_2_motor_left, GPIOA, 11);
  initMotor(&s_motor_left, &s_pin_1_motor_left, &s_pin_2_motor_left);

  initRobot(&g_robot, &s_motor_right, &s_motor_left);
}

/*
 * Initializes the pins of the motors as digital output with default.
 * 	type and speed
 */
void initMotorPin(struct MotorPin *motor_pin, GPIO_TypeDef *gpio, char pin) {
  motor_pin->gpio = gpio;
  motor_pin->pin = pin;

  gpio->MODER &= ~(1 << (pin*2 + 1));
  gpio->MODER |= (1 << (pin*2));

  gpio->OTYPER &= ~(1 << pin);

  gpio->OSPEEDR &= ~(1 << (pin*2 + 1));
  gpio->OSPEEDR &= ~(1 << (pin*2));
}

/*
 * Initializes the motor with the corresponding pins.
 */
void initMotor(struct Motor *motor, struct MotorPin *pin_1, struct MotorPin *pin_2) {
  motor->pin_1 = *pin_1;
  motor->pin_2 = *pin_2;
}

/*
 * Initializes the robot with the motors and stops it.
 */
void initRobot(struct Robot *robot, struct Motor *motor_right, struct Motor *motor_left) {
  robot->motor_right = *motor_right;
  robot->motor_left = *motor_left;

  updateStatusRobot(robot, ROBOT_STOPPED);
}

/*
 * Updates the status of the motor and calls to implement the status.
 */
void updateStatusRobot(struct Robot *robot, enum StatusRobot status) {
  robot->status = status;
  updateRobot(robot);
}

/*
 * Updates the robot to its according status
 *  All the movements are with respect to the whole robot.
 */
void updateRobot(struct Robot *robot) {
  struct StatusMotor status_motor_right, status_motor_left;

  switch (robot->status) {
      case ROBOT_STOPPED:
        status_motor_right = MOTOR_STOPPED;
        status_motor_left = MOTOR_STOPPED;

        break;
      case ROBOT_FORWARD:
        status_motor_right = MOTOR_FORWARD;
        status_motor_left = MOTOR_FORWARD;

        break;
      case ROBOT_BACKWARD:
        status_motor_right = MOTOR_BACKWARD;
        status_motor_left = MOTOR_BACKWARD;

        break;
      case ROBOT_RIGHT:
        status_motor_right = MOTOR_BACKWARD;
        status_motor_left = MOTOR_FORWARD;

        break;
      case ROBOT_LEFT:
        status_motor_right = MOTOR_FORWARD;
        status_motor_left = MOTOR_BACKWARD;

        break;
    }

  updateStatusMotor(&(robot->motor_right), status_motor_right);
  updateStatusMotor(&(robot->motor_left), status_motor_left);
}

/*
 * Updates the status of the motor and calls to implement the status.
 */
void updateStatusMotor(struct Motor *motor, enum StatusMotor status) {
  motor->status = status;
  updateMotor(motor);
}


/*
 * Updates the motor depending of its status
 *  MOTOR_STOPPED: sets the motor to stop
 *  MOTOR_FORWARD: sets the motor to forward with respect to the whole robot
 *  MOTOR_BACKWARD: sets the motor to backward with respect to the whole robot
 *
 *  This is important as one motor cables are swapped to correct that it is flip. (hardware)
 */
void updateMotor(struct Motor *motor) {
  enum StatusMotorPin status_motor_pin_1, status_motor_pin_2;

  switch (motor->status) {
    case MOTOR_STOPPED:
      status_motor_pin_1 = MOTOR_PIN_UP;
      status_motor_pin_2 = MOTOR_PIN_UP;

      break;
    case MOTOR_FORWARD:
      status_motor_pin_1 = MOTOR_PIN_UP;
      status_motor_pin_2 = MOTOR_PIN_DOWN;

      break;
    case MOTOR_BACKWARD:
      status_motor_pin_1 = MOTOR_PIN_DOWN;
      status_motor_pin_2 = MOTOR_PIN_UP;

      break;
  }

  updateStatusMotorPin(&(motor->pin_1), status_motor_pin_1);
  updateStatusMotorPin(&(motor->pin_2), status_motor_pin_2);

}

/*
 * Updates the status of the motor pin and calls to implement the status.
 */
void updateStatusMotorPin(struct MotorPin *motor_pin, enum StatusMotorPin status) {
  motor_pin->status = status;
  updateMotorPin(motor_pin);
}

/*
 * Updates the motor pin depending of its status
 * 	MOTOR_PIN_UP: sets the BSRR register to set the pin to 1
 * 	MOTOR_PIN_DOWN: sets the BSRR register to set the pin to 0
 */
void updateMotorPin(struct MotorPin *motor_pin) {
  switch (motor_pin->status) {
    case MOTOR_PIN_UP:
      motor_pin->gpio->BSRR |= (1 << motor_pin->pin);

      break;
    case MOTOR_PIN_DOWN:
      motor_pin->gpio->BSRR |= (1 << motor_pin->pin) << 16;

      break;
  }

}
